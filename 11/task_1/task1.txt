âœ… Messungen mit verschiedenen ProblemgrÃ¶ÃŸen

ğŸ§ª Testkonfiguration
Compiler: gcc -O1 fÃ¼r baseline, gcc -O1 -ftree-vectorize fÃ¼r auto-vectorized
Messung: clock_gettime + perf stat -e r4010 (FP_COMP_OPS_EXE.SSE_SINGLE_PRECISION)
System: LCC3
ğŸ“Š Messdaten (Wall Clock Time + Speedup)
ProblemgrÃ¶ÃŸe	Repetitionen	Baseline Zeit (s)	Vektorisiert Zeit (s)	Speedup
512	1e6	0.342	0.073	4.68Ã—
1024	1e6	1.036	0.206	5.03Ã—
2048	1e6	2.680	0.514	5.21Ã—
4096	1e6	5.375	1.035	5.19Ã—
8192	1e6	10.752	2.051	5.24Ã—
âœ… Richtigkeit

In allen FÃ¤llen: sum(a) = 12287900672.000000 (bzw. korrekt angepasst fÃ¼r kleinere GrÃ¶ÃŸen)
â†’ Rechengenauigkeit bleibt erhalten âœ…
ğŸ” Beobachtungen zur Performance

Speedup liegt konstant bei etwa ~5Ã— Ã¼ber alle GrÃ¶ÃŸen â†’ sehr effizient.
Kein signifikanter Einbruch bei grÃ¶ÃŸeren ProblemgrÃ¶ÃŸen.
Die Vektorisierung ist linear skalierbar mit dem Problemumfang.
Memory-Bandbreite scheint (noch) nicht limitierend zu sein.
ğŸ“ˆ perf-Analyse (r4010 = SSE Single Precision)

Beispiel perf stat -e r4010 ./vec_baseline 2048 1000000:

Variante	r4010 Events (SSE Instr.)	Zeit (s)
Baseline	4.096.172.587	~2.68
Auto-vectorized	1.024.013.419	~0.51
Interpretation:

Weniger SIMD-Instruktionen bei der vektorisierten Version â‡’ weniger, aber effektivere SIMD-Aufrufe (verarbeiten mehrere float gleichzeitig)
Zeigt, dass Auto-Vektorisierung tatsÃ¤chlich SIMD nutzt â†’ keine "Fake"-Optimierung