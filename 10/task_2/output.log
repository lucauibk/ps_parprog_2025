ERROR: Unable to locate a modulefile for 'gcc/12.2.0'
### N = 2 ###
--- Sequential Version (1 Thread) ---
Delannoy(2, 2) = 13
Time: 0.000000 seconds
--- Parallel Version (1 Thread) ---
Delannoy(2, 2) = 13
Time: 0.000012 seconds
--- Parallel Version (12 Threads) ---
Delannoy(2, 2) = 13
Time: 0.000686 seconds

### N = 4 ###
--- Sequential Version (1 Thread) ---
Delannoy(4, 4) = 321
Time: 0.000003 seconds
--- Parallel Version (1 Thread) ---
Delannoy(4, 4) = 321
Time: 0.000111 seconds
--- Parallel Version (12 Threads) ---
Delannoy(4, 4) = 321
Time: 0.001326 seconds

### N = 7 ###
--- Sequential Version (1 Thread) ---
Delannoy(7, 7) = 48639
Time: 0.000242 seconds
--- Parallel Version (1 Thread) ---
Delannoy(7, 7) = 48639
Time: 0.007288 seconds
--- Parallel Version (12 Threads) ---
Delannoy(7, 7) = 48639
Time: 0.101039 seconds

### N = 12 ###
--- Sequential Version (1 Thread) ---
Delannoy(12, 12) = 251595969
Time: 0.814216 seconds
--- Parallel Version (1 Thread) ---
Delannoy(12, 12) = 251595969
Time: 37.183260 seconds
--- Parallel Version (12 Threads) ---


Exponentielle Anzahl an rekursiven Aufrufen – selbst die parallele Version erzeugt viele kleine Tasks.
Die Berechnungen sind nicht memoisiert → viele identische Teilergebnisse werden mehrfach berechnet.
Task-Overhead: Für kleine m und n ist der Overhead der #pragma omp task größer als die tatsächliche Rechenzeit.
Verbesserung (ohne Algorithmus zu ändern):
Cutoff einführen, z.B.:
if (m + n < CUTOFF) {
    return delannoy(m-1, n) + delannoy(m-1, n-1) + delannoy(m, n-1);
}
Nur für größere Teilprobleme Tasks erzeugen.